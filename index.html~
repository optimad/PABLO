<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Pablo by optimad</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
        <table>
        <tr>
        <th><h1>Pablo</h1><h2>PArallel Balanced Linear Octree</h2><h6>developed by </h6><h5><a href="http://www.optimad.it"><FONT COLOR="#d5000d">Optimad engineering srl</FONT></a></h5></th>
        <th><img src="./images/pablonoscritta150x150.png" height="80"></th>
	</tr>
	</table>
        </header>

        <section id="downloads" class="clearfix">
 <!--         <a href="https://github.com/optimad/PABLO/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a> -->
          <a href="https://github.com/optimad/PABLO" id="view-on-github" class="button"><span>View on GitHub</span></a>
          <a href="http://optimad.github.io/PABLO/html/index.html" id="view-on-github" class="button"><span>View Doxygen</span></a>
          <a href="https://github.com/optimad/PABLO/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
        </section>

        <hr> 

        <section id="main_content">
 
 <!--          <h3>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Welcome to Pablo Pages.</h3> -->
        <header>
	<h2>Who is PABLO</h2> 
	<p><h11>PABLO is C++/MPI library for parallel linear octree/quadtree developed by <a href="http://www.optimad.it"><FONT COLOR="#303030">Optimad Engineering srl</FONT></a> under the GNU Lesser General Public License. The aim of the project is to provide users with a ready-to-use tool for parallel adaptive grid of quadrilaterals/hexahedra. Message passing paradigm is transparent to the user since MPI calls are embedded in PABLO. By this way, the user can easily perform data communications and dynamic load-balance by calling straightforward high level methods. Moreover, the user can feel free to customize his data in whatever way he likes.
	PABLO allows adaptive mesh refinement by generating non-conforming grid with hanging nodes. One of the main feature of PABLO is the low memory consumption in the basic configuration (approx. 30B per octant in 3D). Additional features available in PABLO are: 2:1 balancing between octants and a easy way to generate and store intersections between octants. </h11></p>
	
        <hr> 

	<h2>Tutorials</h2>
	<!--<p><h11>Some tutorials on the use of PABLO library are described here below. This web page is not an user guide or a programmer manual, but only a brief description of the results obtained by running some examples. All the reults here illustrated are obtained from the test files in the repository. Here no code is shown, but one can follow the description of the tutorials by reading comments and code in the test files. The first six tests (0/5) are two-dimensional serial example about the use of basic methods of PABLO to generating and managing quadtree meshes. Analogous tests are explained for parallel applications in the following five examples (12/16). Finally the results of two tests (104/116) for three-dimensional cases are described. </h11></p> -->
	<p><h11>In this section, results obtained by running the examples available in PABLO are presented. For a detailed description of each test case, please refer to tests code available in PABLO. (For technical information about PABLO, please visit <a href="http://optimad.github.io/PABLO/html/index.html"><FONT COLOR="#303030">Doxygen documentation</FONT></a>). </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 0</FONT></h5>
	<!-- <p><h11>The first file <em>test0.cpp</em> is a simple tutorial about the instantation of octree objects. In this example two 2-dimensional objects of class <em>Para_Tree</em> are declared. The first one by using the default constructor, that builds a quadtree with one quadrant with size 1 and coordinates of node 0 in the origin. The second quadtree is instantiated by custom constructor, passing as input parameter the coordinates of node 0 equal to (10,20,0) and the size of the quadrant equal to 250. Note that PABLO works in a logical domain (maximum size of the first ancestor quadrant in logical domain equal to 2<span class=sup><i>m</i></span>, with m=maximum refinement level allowed; while minimum size of finest quadrant equal to 1), the transformation from the logical domain to the physical one has to be implemented by the user in a particular class (Class_Map); by default a simple translation/scaling is supplied with the repository. The two quadtrees are saved in logical coordinates and in physical ones. The figure below shows both the quadtrees in logical domain. </h11></p>
	<img src="./TestFiles/test0_logical.png">
	<p><h11>Note that the two quadrants are exactly overlapped, in effect they have the same coordinates and size in the logical domain.
	In the next figure the same quadtrees are displayed in the physical domain.</h11></p>
	<img src="./TestFiles/test0_physical.png">
	<p><h11>Here the two quadrants are highly different in size (1/250), quadrant with size 1 in blue and quadrant with size 250 in red, and for the coordinates of their node 0.</h11></p> -->
	
	<p><h11>The first tutorial (available in <em>test0.cpp</em>) is a simple tutorial about instantiation of octree objects. In this example two 2-dimensional class <em>Para_Tree</em> objects are declared using the default constructor and a custom constructor. <em>Class_Para_Tree</em> standard constructor builds a quadtree with just one quadrant with unity edge length and node 0 in axis origin. Class_Para_Tree custom constructor instantiates a quadtree with just one quadrant with edge length provided by the user (equal to 250, in this example) and node 0 with coordinates specified by user (in this example (10,20,0)). PABLO works in a logical domain where the maximum size allowed for a quadrant cannot exceed 2<span class=sup><i>m</i></span> (m is the maximum refinement level), and minimum size of a quadrant is equal to 1. Therefore, different quadtrees in the physical domain (see first figure), are mapped into the same quadtree in the logical domain (see second figure).  Figure below shows both quadtrees in the physical domain. The first quadtree (instantiated with the default constructor) is shown in blue, while the second octree (created by the custom constructor) is depicted in red. Note that the size ratio between both quadrant is 1/250. </h11></p>
	<img src="./TestFiles/test0_logical.png">
	 <p><h11>Figure below shows both quadtrees in the logical domain. Here both octrees are mapped into the same octree with edge length 2<span class=sup><i>m</i></span>. </h11></p>
	<img src="./TestFiles/test0_physical.png">
	<p><h11> Transformation from logical domain to physical domain must be provided by user within the class Class_Map, although a simple transformation composed of translation and scaling is already available in PABLO. Both quadtrees generated in this tutorial can be saved in both logical and physical coordinates. </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 1</FONT></h5>
	<p><h11>In this test (<em>test1.cpp</em>) one quadtree is first refined globally one time, then is refined iteratively marking <em>to be refined</em> (<em>i.e.</em> marker=1) all the quadrants with the center inside a circle. At the end of the test one global refinement is performed again. The results is shown in the video below, starting from the ancestor quadrant up to the last global refinement. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/Fi8ckFfBlQM?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>Note that in the right half-side of the domain the 2:1 balance is deactivated. Moreover in the lower part of the domain simple consequential refinements are achieved, while in the upper part a <em>while</em> loop is performed in order to refine geometrically even new quadrant obtained by 2:1 balancing potentially inside the area of the circle. </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 2</FONT></h5>
	<p><h11>The video below displays the result obtained by <em>test2.cpp</em>. This Test is analogous to the Test 1 with the 2:1 balance active for the whole domain and only simple adapting performed. The main difference is that the geometrically condition to set marker=1 is not imposed if the center of an quadrant lies in the circle but if at least one of its nodes is inthe area of the circle.  </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/S-mwu-Bc3Pk?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>In the video can be noted as the refinements are smoother and the geomtry is better captured. This because no-one quadrant is not refined after its born in 2:1 balancing procedure, but these quadrants are already refined by using the condtion on nodes rather than on centers.  </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 3</FONT></h5>
	<p><h11>The <em>test3</em> starts from the end point of the previous test. This tutorial involves the use of the adapting method to caorse the mes in an area of the domain. In particular a smaller circle is defined and the marker of every quadrant that lies inside is set equal to -1 (<em>i.e.</em> to be coarsened) and the 2:1 balance deactivated. This procedure is repeated 5 times as it can be seen in the video below. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/m16Lb9WjtKw?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>Note that a global coarsening of one level is performed before the adaptive procedure in the smaller circle.</h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 4</FONT></h5>
	<p><h11>This test (see <em>test4.cpp</em>) involves the use of the methods to find the neighbour quadrants of an element. In PABLO one can search the neighbour elements through faces, edges and nodes (in 2D case only edges and nodes). In this example an quadtree is refined four levels and then a set of data is defined over the obtained mesh. In particular the data are intialized equal to 1 inside a circle and 0 outside. The method to find neighbours is used to perform a simple moving average smoothing procedure of the data. The video below shows the evolution of the data during 25 iterations of smoothing. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/X0m5rkoZZWE?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>Note that the neighbours are evaluated both through edges both through nodes, using all the 8 quadrants of the 1-ring stencil. In the file <em>test4.cpp</em> vectors related to ghost elements and ghost data are used, this is necessary because of the implementation of the methods of the library, but in serial application like this one they are never involved in computations (they are empty). </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 5</FONT></h5>
	<p><h11>In this example the use of PABLO in a simple adaptive mesh refinement with data associated to a mesh. A set of data (value 0 assigned to the quadrants outside a circle and the distance from the center to the quadrants inside) is linked to a uniform grid of level 5. Then half side of the circle is marked to be refined (marker=1) and the other quadrants to be coarsen (marker=-1). The data on the new mesh are injected following these rules: the value of a father quadrant is inherited by the children and the average of the values of four children is assigned to a father appeared after a coarsening step. This can be done by the method <em>adapt</em> of PABLO with the use of the optional auxiliar mapper that links the grid before and after an adapting step. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/wvIehBfXGEA?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>In the video above the results of two step of refinement/coarsening with data injection over grids are shown. Obviously the code can be found in source file <em>test5.cpp</em>. </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 12</FONT></h5>
	<p><h11>The example of <em>test12.cpp</em> is identical to Test 2 except that it is a parallel application instead of serial one. Now after some refinement the mesh is balanced over the processes after each refinement step. In the video below the refinement and the balancing procedures are shown displaying the obtained mesh at each step. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/ktphfrMup3A?rel=0" frameborder="0" allowfullscreen></iframe>
	 <p><h11>Note that different partitions of the mesh are represented by different colors. The test is performed by using 4 processes. </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 13</FONT></h5>
	<p><h11>Test 3 is proposed here in its parallel version. The load-balancing is performed again after each step of grid adapting. Note in the video below that the simmetry of the mesh partition is lost at the time that the simmetry of the mesh topology is lost. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/kBr60Io8y2M?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 14</FONT></h5>
	<p><h11>Again this example is analogous to Test 4 but parallelized. In this test the data are communicated over the processes in order to perform the smoothing procedure. Now in vectors with ghost quadrants and ghost data are stored elements and values, used in the communications and in the computations. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/pn9AwgYi99E?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>The video above shows the results obtained during 25 iterations of smoothing, running the code in parallel by using 4 processes. </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 15</FONT></h5>
	<p><h11>In this example a parallel load-balance is performed. Again the main application is the same of test 5: the inheritage of data after an adapting step. However here a next challenge is added. The load-balance of the mesh is performed, passing from serial to parallel computation, with linking and distributing data between the processes. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/Uq-2YFCa2K0?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>In the video above the partitioning with data is displayed in the last frame. </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 16</FONT></h5>
	<p><h11>The same example of Test 15 is here enriched by an additional feature. Indeed, now the load-balance is performed by maintaining compact over the same process a family of desired level. In particular in the example of <em>test16.cpp</em> families of four levels upper the maximum deep reached in the quadtree are keeped in the same partition. The video below show the obtained result. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/5tCcpHoaFRA?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>Compare the last frame of this video with the last frame of video of Test 15 to understand the difference between the achieved partitions with and without the <em>"compact families"</em> feature. </h11></p>
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 104</FONT></h5>
	<p><h11>In this example the same smoothing procedure of Test 4 are repeated for a three-dimensional octree, by substituting simply the specialization parameter in the declaration of the object octree. Moreover, because we are now in three dimensions, a loop over the faces during the neighbour search is performed. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/YftCYuTcDeg?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 116</FONT></h5>
	<p><h11>The load-balance example with data and compact families over the processes of Test 6 is here rerun for a three-dimensional octree mesh. In the video below the evolution during mesh generation and partitioning. </h11></p>
	<iframe width="560" height="315" src="//www.youtube.com/embed/3tkahH4PyQ0?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	</header>


<!--

<p>This automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:</p>

<pre><code>$ cd your_repo_root/repo_name
$ git fetch origin
$ git checkout gh-pages
</code></pre>

<p>If you're using the GitHub for Mac, simply sync your repository and you'll see the new branch.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Designer Templates</h3>

<p>We've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Rather Drive Stick?</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>You can <a href="https://github.com/blog/821" class="user-mention">@mention</a> a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages">http://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and we’ll help you sort it out.</p>
        
        -->
        
        </section>

        <footer>
          Pablo is maintained by <a href="https://github.com/optimad">optimad</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>