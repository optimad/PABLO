<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Pablo by optimad</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
        <table>
        <tr>
        <th><h1>Pablo</h1><h2>PArallel Balanced Linear Octree</h2><h6>developed by </h6><h5><a href="http://www.optimad.it"><FONT COLOR="#d5000d">Optimad engineering srl</FONT></a></h5></th>
        <th><img src="./images/pablonoscritta150x150.png" height="80"></th>
	</tr>
	</table>
        </header>

        <section id="downloads" class="clearfix">
 <!--         <a href="https://github.com/optimad/PABLO/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a> -->
          <a href="https://github.com/optimad/PABLO" id="view-on-github" class="button"><span>View on GitHub</span></a>
          <a href="http://optimad.github.io/PABLO/doxy/html/index.html" id="view-on-github" class="button"><span>View Doxygen</span></a>
          <a href="https://github.com/optimad/PABLO/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
        </section>

        <hr> 

        <section id="main_content">
 
 <!--          <h3>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Welcome to Pablo Pages.</h3> -->
        <header>
	<h2>Who is PABLO</h2> 
	<p><h11>PABLO is C++/MPI library for parallel linear octree/quadtree developed by <a href="http://www.optimad.it"><FONT COLOR="#303030">Optimad Engineering srl</FONT></a> under the GNU Lesser General Public License. The aim of the project is to provide users with a ready-to-use tool for parallel adaptive grid of quadrilaterals/hexahedra. Message passing paradigm is transparent to the user since MPI calls are embedded in PABLO. By this way, the user can easily perform data communications and dynamic load-balance by calling straightforward high level methods. Moreover, the user can customize his data in whatever way he likes or he can use a simple data structure already available in PABLO.
	PABLO allows adaptive mesh refinement by generating non-conforming grid with hanging nodes. One of the main feature of PABLO is the low memory consumption in the basic configuration (approx. 30B per octant in 3D). Additional features available in PABLO are: 2:1 balancing between octants and a easy way to generate and store intersections between octants. </h11></p>
	
        <hr> 

	<h2>Tutorials</h2>
	<p><h11>In this section, results obtained by running the examples available in PABLO are presented. For a detailed description of each test case, please refer to tests code available in PABLO. (For technical information about PABLO, please visit <a href="http://optimad.github.io/PABLO/doxy/html/index.html"><FONT COLOR="#303030">Doxygen documentation</FONT></a>). </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 0</FONT></h5>
	<p><h11>The first tutorial (available in <em>test0.cpp</em>) is a simple tutorial about instantiation of octree objects. In this example two 2-dimensional class <em>Para_Tree</em> objects are declared using the default constructor and a custom constructor. <em>Class_Para_Tree</em> standard constructor builds a quadtree with just one quadrant with unity edge length and node 0 in axis origin. Class_Para_Tree custom constructor instantiates a quadtree with just one quadrant with edge length provided by the user (equal to 250, in this example) and node 0 with coordinates specified by user (in this example (10,20,0)). PABLO works in a logical domain where the maximum size allowed for a quadrant cannot exceed 2<span class=sup><i>m</i></span> (m is the maximum refinement level), and minimum size of a quadrant is equal to 1. Therefore, different quadtrees in the physical domain (see first figure), are mapped into the same quadtree in the logical domain (see second figure).  Figure below shows both quadtrees in the physical domain. The first quadtree (instantiated with the default constructor) is shown in blue, while the second octree (created by the custom constructor) is depicted in red. Note that the size ratio between both quadrant is 1/250. </h11></p>
	<img src="./TestFiles/test0_physical.png" align="middle">
	 <p><h11>Figure below shows both quadtrees in the logical domain. Here both octrees are mapped into the same octree with edge length 2<span class=sup><i>m</i></span>. </h11></p>
	<img src="./TestFiles/test0_logical.png" align="middle">
	<p><h11> Transformation from logical domain to physical domain must be provided by user within the class Class_Map, although a simple transformation composed of translation and scaling is already available in PABLO. Both quadtrees generated in this tutorial can be saved in both logical and physical coordinates. </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 1</FONT></h5>
	<p><h11>In this tutorial (available in <em>test1.cpp</em>), a quadtree is refined globally one time, and then refined iteratively using two different refinement criteria.  At the end of the iterative refinement, one global refinement is performed again. In the first criterion, each octant generated by a previous refinement iteration is marked for further refinement if its center is within a circle with a specified radius. Iterative refinement stops when a fixed number of iteration is reached. In the second criterion, the refinement is performed using the same rules of the first criterion. However, this refinement is performed until the flag returned by the <em>adapt</em> method is true (for further details about <em>adapt</em> method, please visit <a href="http://optimad.github.io/PABLO/html/class_class___para___tree_3_012_01_4.html"><FONT COLOR="#303030">documentation</FONT></a>). Video below illustrates the iterative refinement. Each frame show the result of a refinement iteration starting from the ancestor quadrant up to the last global refinement. The upper part of each frame shows the refinement procedure using the first criterion, while the bottom part shows the refinement procedure using the second criterion. Moreover, in the right hand side of the domain, the 2:1 balancing is deactivated. </h11></p>
	<iframe width="620" height="340" align="middle" src="//www.youtube.com/embed/Fi8ckFfBlQM?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 2</FONT></h5>
	<p><h11>In this tutorial (available in <em>test2.cpp</em>) a quadtree is iteratively refined using a slight modification of the first refinement criterion of Tutorial 1. Here, each octant is marked for further refinement if at least one of its vertices lies within a circle of specified radius. Again the iterative refinement is performed for a specified number of iterations. Video below shows the refinement procedure. Using the present criterion the geometry is captured better than in tutorial 1.   </h11></p>
	<iframe width="620" height="340" align="middle" src="//www.youtube.com/embed/S-mwu-Bc3Pk?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 3</FONT></h5>
	<p><h11>This tutorial (available in <em>test3.cpp</em>) starts from the result of tutorial 2, and shows the use of the method <em>adapt</em> for coarsening. In this example, a global coarsening iteration is performed, followed by an iterative coarsening of each quadrant within a smaller circle inside the original geometry. The coarsening procedure is repeated 5 times and the 2:1 balancing option is de-activated. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/m16Lb9WjtKw?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
	
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 4</FONT></h5>
	<p><h11>This tutorial (available in <em>test4.cpp</em>) shows how to use PABLO's methods to find neighboring quadrants of a specified element. Neighbors search can be performed through faces, edges and nodes (in 2D case, only edges and nodes). In this example a quadtree is refined four times and then a set of data is assigned to the mesh using STL vectors. More specifically, an integer equal to 1 is assigned uniformly to all quadrants within a circle, and 0 to the remaining quadrants. In this example neighbor-search is used to perform a simple moving-average-smoothing procedure of the data. Video below shows the time-evolution of data over 25 smoothing iterations. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/X0m5rkoZZWE?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11> Note that in <em>test4.cpp</em>, vectors for ghost cells (and related data) are also introduced. This is required by the parallel nature of methods implementation in PABLO, even though such vectors are never used on serial-runs like the present one. </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 5</FONT></h5>
       <p><h11>This tutorial (available in  <em>test5.cpp</em>) shows how to use PABLO for adaptive mesh refinement with data associated to the mesh. A set of data (value 0 assigned to all quadrants outside a circle, and value equal to the distance from circle's center assigned to all quadrants within the circle) is linked to a uniform quadtree of level 5. Quadrants within the left half of the circle are marked for refinement, while quadrants in the right half for coarsening. Data are mapped onto the mesh after refinement following these rules: the value of a father is inherited by its children (in case of refinement); the average sum of values of the four children is assigned to the father (in case of coarsening). Data injection can be achieved after adaptation using an auxiliary mapper provided by an overloaded version of the <em>adapt</em> method. This mapper links the grid before and after adaptation. Video above shows the results after two steps of refinement/coarsening with data injection over the new grid. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/wvIehBfXGEA?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 12</FONT></h5>
	<p><h11>The example in <em>test12.cpp</em> is the parallel version of test2.cpp. Here one quadtree is instantiated in the same way on every process. Therefore, each process refines globally the initial quadrant 3 times. Till this moment, there's no parallel paradigm in action, actually the code is replicated on every process. At this point a load-balance method call is performed and the grid is partitioned and distributed among the processes of the world communicator. From now on, each process owns one portion of the grid. The test continues as in tutorial 2, but after every refinement a load-balance call is introduced to keep the computational burden well distributed. In the following video each frame shows the mesh and the processor partitions after every refinement. Different partitions are represented with different colors. The test has been performed using 4 processes.  </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/ktphfrMup3A?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 13</FONT></h5>
       <p><h11>Test 3 is proposed here in its parallel version. The load-balancing is performed after each step of grid adapting, as in test 12. In the following video, remark how loosing the symmetry in the mesh affects the symmetry of the process partition.</h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/kBr60Io8y2M?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 14</FONT></h5>
	<p><h11>The example in <em>test14.cpp</em> is the parallel version of test4.cpp. In order to perform the smoothing procedure in parallel, ghost elements and data communications towards them are needed. Now ghost quadrants and ghost data are not only instantiated, as in test 4, but actually used to perform smoothing across processor borders. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/pn9AwgYi99E?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11> In the previous video, every frame shows one of the 25 smoothing steps. Four processes have been used for this run. </h11></p>
       
       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 15</FONT></h5>
	<p><h11>This test is the parallel version of <em>test5.cpp</em>. Here the main focus is on the load-balance of both grid (as in <em>test13.cpp</em>) and data. The grid is refined several times together with the data and their inheritance follows the same rules like in test 5. Until the last refinement no parallel paradigm is in action: every process owns the entire grid. After this refinement, the load-balance with data is introduced, giving as result a parallel distribution of grid (as in <em>test13.cpp</em>) and data. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/9MvwD8ecpNg?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>In the video above data are represented with colors in cell, while the process partition is highlighted coloring the cell edges. </h11></p>
	
	<hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 16</FONT></h5>
       <p><h11> Test 15 is here enriched by an additional feature. The load-balance is performed by keep a family of desired level together on the same process. In particular in this example (see test16.cpp) the families, containing elements from the maximum level reached in the quadtree to that level minus 3, are kept on the same partition. The video below show the obtained result. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/Y3Lky_zKJ6o?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>Compare the last frame of this video with the last frame of video of Test 15 to understand the difference between the achieved partitions with and without the <em>"compact families"</em> feature. </h11></p>
	
	<hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 104</FONT></h5>
	<p><h11>In this example the same smoothing procedure of test 4 are repeated for a three-dimensional octree, by simply substituting the specialization parameter in the declaration of the octree object. Moreover, since we are now in three dimensions, a loop over the faces during the neighbour search is performed. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/YftCYuTcDeg?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 116</FONT></h5>
	<p><h11>The load-balance example with data and "compact families" in test 6 is here rerun for a three-dimensional octree mesh. In the following video the evolution during mesh generation and partitioning is shown. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/gEXxxi9tMTw?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>

       <hr> 

	<h5><FONT COLOR="#aaa">Tutorial Test 120</FONT></h5>
	<p><h11>In this example an Adaptive Mesh Refinement (AMR) around a moving sphere is performed. In the following videos the evolution of the partitioning (6 processes) and mesh adaptation during the motion of the sphere are shown. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/LlLN5Ti2dvI?rel=0" frameborder="0" allowfullscreen></iframe>
       <hr> 
	<iframe width="620" height="340" src="//www.youtube.com/embed/6zifrGjNyIc?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
	
       <hr> 
	
	<h5><FONT COLOR="#aaa">Tutorial Test Bubbles</FONT></h5>
	<p><h11>In this example an Adaptive Mesh Refinement (AMR) for tracking moving bubbles in 2D is performed. In the following video the evolution of the partitioning (8 processes) and mesh adaptation during bubbles motion are displayed. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/9IUc0GeavWg?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
	
       <hr> 
       
	<h5><FONT COLOR="#aaa">Tutorial Test Bubbles 3D</FONT></h5>
	<p><h11>In this example an Adaptive Mesh Refinement (AMR) for tracking moving bubbles in 3D is performed (8 processes). In the following video the mesh adaptation and the bubbles evolution are shown. </h11></p>
	<iframe width="620" height="340" src="//www.youtube.com/embed/kX7VLdMThAk?rel=0" frameborder="0" allowfullscreen></iframe>
	<p><h11>&nbsp; </h11></p>
	
       <hr> 
       
       </header>


<!--

<p>This automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here using GitHub Flavored Markdown, select a template crafted by a designer, and publish. After your page is generated, you can check out the new branch:</p>

<pre><code>$ cd your_repo_root/repo_name
$ git fetch origin
$ git checkout gh-pages
</code></pre>

<p>If you're using the GitHub for Mac, simply sync your repository and you'll see the new branch.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Designer Templates</h3>

<p>We've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.</p>

<h3>
<a name="rather-drive-stick" class="anchor" href="#rather-drive-stick"><span class="octicon octicon-link"></span></a>Rather Drive Stick?</h3>

<p>If you prefer to not use the automatic generator, push a branch named <code>gh-pages</code> to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.</p>

<h3>
<a name="authors-and-contributors" class="anchor" href="#authors-and-contributors"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>You can <a href="https://github.com/blog/821" class="user-mention">@mention</a> a GitHub username to generate a link to their profile. The resulting <code>&lt;a&gt;</code> element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (<a href="https://github.com/defunkt" class="user-mention">@defunkt</a>), PJ Hyett (<a href="https://github.com/pjhyett" class="user-mention">@pjhyett</a>), and Tom Preston-Werner (<a href="https://github.com/mojombo" class="user-mention">@mojombo</a>) founded GitHub.</p>

<h3>
<a name="support-or-contact" class="anchor" href="#support-or-contact"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Having trouble with Pages? Check out the documentation at <a href="http://help.github.com/pages">http://help.github.com/pages</a> or contact <a href="mailto:support@github.com">support@github.com</a> and weâ€™ll help you sort it out.</p>
        
        -->
        
        </section>

        <footer>
          Pablo is maintained by <a href="https://github.com/optimad">optimad</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>